
We hebben gegeven: \\
$ A =\begin{bmatrix} 
 2 & 1 & -1 \\
 0 & 3 & -5 \\
 0 & 0 & -2\\
\end{bmatrix}$
$ X_0 = \begin{bmatrix}
-1.00001 \\
1.00002 \\
1 \\
\end{bmatrix} $ \\
De matrix A is een bovendriehoeksmatrix, dit wil zeggen dat we de eigenwaarden van A vinden op de hoofddiagonaal: $\lambda_1 = 2$,$\lambda_2 = 3$, $\lambda_3 = -2$. Hieruit leiden we af dat de dominante eigenwaarde 3 is. De methode van de machten zal dus normaal eerst naar de dominante eigenwaarde convergeren. Indien we de eigenvectoren van A berekenen, horende bij de eigenwaarden, dan vinden we: \\

$ E1 = \begin{bmatrix}
1 \\
0 \\
0 \\
\end{bmatrix} E2 = \begin{bmatrix}
1 \\
1 \\
0 \\
\end{bmatrix}  E3 = \begin{bmatrix}
0\\
1 \\
1 \\
\end{bmatrix}$ \\

(We berekenden deze eigenvectoren met de formule: $(A-\lambda I)=0$ ) voorbeeld voor $\lambda_1 = 2$:

$ A =\begin{bmatrix} 
 0 & 1 & -1 \\
 0 & 1 & -5 \\
 0 & 0 & -4\\
\end{bmatrix} \begin{bmatrix}
X_1 \\
X_2 \\
X_3 \\
\end{bmatrix} = \begin{bmatrix}
0 \\
0 \\
0 \\
\end{bmatrix} $ \\
We lossen dit stelsel op: \\
$-4X_3 = 0 $ \\
$X_2 - 5X_3 = 0 $ \\
$X_2 - X_3 = 0 $ \\
We merken op dat $X_1$ een vrije variabele is, voor de gemakkelijkheid stellen we deze gelijk aan 1 achteraf.
We krijgen dan: \\
$X_1 = 1 $ \\
$X_1 = X_3 = 0 $ \\
Wat ons de uitgekomen eigenvector E1 geeft. De werkwijze voor de overige 2 eigenvectoren is identiek. \\
We merken nu dat de startvector 
$ X_0 = \begin{bmatrix}
-1.00001 \\
1.00002 \\
1 \\
\end{bmatrix} $
ongeveer een lineaire combinatie is van de 2 eigenvectoren E1 en E3. Hierdoor zit de iteratie van het algoritme in het begin vast in het vlak van deze 2 eigenvectoren. Door de lichte afwijking op de vector (de .00001) komt de vector na genoeg iteraties toch uit het vlak en gaan we naar 3 itereren. Moest de startvector exact een lineaire combinatie van 2 eigen vectoren zijn dan zou men nooit naar 3 convergeren. (zie ook oefenzitting 10, Matlab sessie, daar hebben we ongeveer hetzelfde gedaan). De grafiek van de norm van de gevonden vector is ook gegeven en daar zie je dat hij eerst een tijd op 2 staat en dan pas na 20 stappen begint te schommelen en toch naar 3 gaat. Waarom? Omdat hij pas de afwijking van de ideale waarden (de .00001) gaat zien nadat de iteratieve methode de juiste precisie heeft bereikt. Dat wil zeggen na 20 stappen (1 stap is 1 bit en 3 bits per getal nauwkeurig $=>$ 20 stappen voor 6 getallen nauwkeurig). We maken gebruik van een genormaliseerde vorm om overloop of onderloop te vermijden. Door normalisatie gaat de norm van een vector namelijk beperkt zijn en is er dus minder kans op overloop/onderloop. De methode zal enkel naar $\lambda$ convergeren als $\lambda$ dominant is en de startvector een component heeft overeenkomstig met de eigenvector van $\lambda$. In de praktijk hang de bruikbaarheid van de von Mises methode af van de verhouding $\frac{| \lambda_2 |}{| \lambda_1 |}$ , de convergentiefactor. De methode kan falen om verschillende redenen: \\
\begin{itemize}
\item Startvector heeft geen component in de richting van de dominante eigenvector. (dit is als $\alpha$=0) In de praktijk zal dit probleem niet vaak voorkomen omdat afrondingsfouten vaak toch een component in die richting garanderen.
\item Er kunnen meerde eigenwaarden zijn met dezelfde (maximum) modules. De methode kan dan convergeren naar een lineaire combinatie van de overeenkomstige eigenvectoren.
\item Voor een re\"ele matrix en startvector, kan de methode nooit convergeren naar een complexe vector.
\end{itemize}
Zie ook vraag 4 van het opgeloste examen door van Barel zelf (ongeveer gelijke vraag).
